---
layout: post
title: Zookeeper
tag: Zookeeper
---

## JVM 相关

### Java 中的对象都是在堆中分配吗？

#### 什么是逃逸分析？
关于 Java 逃逸分析的定义：

逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。

逃逸分析的 JVM 参数如下：

* 开启逃逸分析：-XX:+DoEscapeAnalysis
* 关闭逃逸分析：-XX:-DoEscapeAnalysis
* 显示分析结果：-XX:+PrintEscapeAnalysis
* 逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。

#### 对象逃逸状态

我们了解了 Java 中的逃逸分析技术，再来了解下一个对象的逃逸状态。

##### 1、全局逃逸（GlobalEscape）
即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：

* 对象是一个静态变量
* 对象是一个已经发生逃逸的对象
* 对象作为当前方法的返回值
##### 2、参数逃逸（ArgEscape）
即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。

##### 3、没有逃逸
即方法中的对象没有发生逃逸

#### 逃逸分析优化

针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。

##### 1、锁消除

我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。

例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。

锁消除的 JVM 参数如下：

* 开启锁消除：-XX:+EliminateLocks
* 关闭锁消除：-XX:-EliminateLocks

锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。

##### 2、标量替换

首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。

对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

标量替换的 JVM 参数如下：

* 开启标量替换：-XX:+EliminateAllocations
* 关闭标量替换：-XX:-EliminateAllocations
* 显示标量替换详情：-XX:+PrintEliminateAllocations

标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

##### 3、栈上分配

当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。

#### 总结

逃逸分析讲完了，总结了不少时间，我们也应该大概知道逃逸分析是为了优化 JVM 内存和提升程序性能的。

我们知道这点后，在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。

简单举一个例子吧，如：
```java
return sb;
```
可以改为：
```java
return sb.toString();
```
这是一种优化案例，把 StringBuilder 变量控制在了当前方法之内，没有逃出当前方法作用域。

### 什么是 TLAB ？

什么是 TLAB ？它是干什么的 ？先抛开这个问题，一切的开始得从 new 对象到指针碰撞开始讲起。

#### new 对象与指针碰撞

new 对象怎么就出问题了呢？
java 中我们要创建一个对象，用关键字 new 就可以了。但是，在我们日常中，有很多生命周期很短的对象。比如：
```java
public void dome(){
    User user=new user();
    user.sayhi();
}
```

这种对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。

假设 JVM 所有的对象都放在堆内存中 (为什么用假设，因为 JVM 并不是这样) 一旦方法结束，没有了指向该对象的引用，该对象就需要被 GC 回收，如果存在很多这样的情况，对 GC 来说压力山大呀。

#### 那么什么又是指针碰撞呢？

假设 JVM 虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象 size 的距离。这就被称为指针碰撞。

好，问题来了。如果我们多线程执行刚才那个 dome 方法，一个线程正在给 A 对象分配内存，指针还没有来的及修改，其它为 B 对象分配内存的线程，而且还是引用这之前的指针指向。这样就出现毛病了。
(要注意的是，上面两种情况解决方案不止一个，我今天主要是讲 TLAB，其他方案自行查询)

#### TLAB 的出现

我们现在已经搞清楚，我们出现了哪些问题。我在为大家介绍一下今天的主角。
TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。

如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。

TLAB 空间的内存非常小，缺省情况下仅占有整个 Eden 空间的 1%，也可以通过选项 - XX:TLABWasteTargetPercent 设置 TLAB 空间所占用 Eden 空间的百分比大小。

TLAB 的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从 Eden 分配一块空间，例如说 100KB，作为自己的 TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住 eden 里的一块空间不让其它线程来这里分配。

TLAB 只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为 线程私有分配区 更为合理一点
当一个 TLAB 用满（分配指针 top 撞上分配极限 end 了），就新申请一个 TLAB，而在老 TLAB 里的对象还留在原地什么都不用管 —— 它们无法感知自己是否是曾经从 TLAB 分配出来的，而只关心自己是在 eden 里分配的。

#### TLAB 的缺点

事务总不是完美的，TLAB 也又自己的缺点。因为 TLAB 通常很小，所以放不下大对象。
* TLAB 空间大小是固定的，但是这时候一个大对象，我 TLAB 剩余的空间已经容不下它了。(比如 100kb 的 TLAB，来了个 110KB 的对象)
* TLAB 空间还剩一点点没有用到，有点舍不得。(比如 100kb 的 TLAB，装了 80KB，又来了个 30KB 的对象)
所以 JVM 开发人员做了以下处理，设置了最大浪费空间。
当剩余的空间小于最大浪费空间，那该 TLAB 属于的线程在重新向 Eden 区申请一个 TLAB 空间。进行对象创建，还是空间不够，那你这个对象太大了，去 Eden 区直接创建吧！
当剩余的空间大于最大浪费空间，那这个大对象请你直接去 Eden 区创建，我 TLAB 放不下没有使用完的空间。
当然，又回造成新的病垢。
* Eden 空间够的时候，你再次申请 TLAB 没问题，我不够了，Heap 的 Eden 区要开始 GC，
* TLAB 允许浪费空间，导致 Eden 区空间不连续，积少成多。以后还要人帮忙打理。
